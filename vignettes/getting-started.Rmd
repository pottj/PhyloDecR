---
title: "Getting Started with the PhyloDecR tool"
subtitle: "Algorithm to detect fixing taxa"
author: "Dr. Janne Pott (janne.pott@uni-leipzig.de)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with the PhyloDecR tool}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
lang: en
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = T
)
```

```{r setup, warning=FALSE, message=FALSE}

library(data.table)
setDTthreads(1)
library(foreach)
library(PhyloDecR)

```

# Preamble

This document is supposed to explain the algorithm used in the PhyloDecR package. It shortly describes the main steps. 

For more information see XXX. 

The functions are within two main files:

* myAlgorithm.R 
  * check for fixing taxa in a given data set
  * input: data set with status (input, unresolved, [resovled]), index number (how many times was this data set tested yet?), verbose
  * output: data set with updated status (input, unresolved, [resovled])
* runAlgorithm.R
  * run algorithm in a repeat - break loop
  * loop breaks if there are no new resolved quadruples per index or no unresolved quadruples left
  * input: data set with status (input, unresolved, [resovled])
  * output: data set with updated status (input, unresolved, [resovled]) and round information (when did algorithm fail?)

# Step 0: Create input data

As example data, we use one quadruple set from Mareike Fischers Mathematica Algorithm: 

* {1,2,3,5},
* {1,3,5,6},
* {2,3,5,6},
* {1,2,3,6},
* {2,3,4,6},
* {1,3,4,6},
* {1,2,4,6},
* {1,2,5,6},
* {1,4,5,6},
* {1,2,4,5}, and 
* {2,3,4,5}

We already know that this quadruple set is phylogenetic decisive. The quadruple are also stored in the **PhyloDecR** example data and can be read in easily with the *createInput()* function.

```{r createInput}
fn = system.file("extdata", "example_2_Decisive.txt", package = "PhyloDecR")
test = createInput(fn=fn,sepSym = ",")
verbose = T
data = test$data
data[status=="input",quadruple]
knitr::kable(test$data, caption = "Input data")

```

# Step 1: Initialize

## Check column names

The PhyloDecR algorithm expects all columns generated by *createInput()*. In the first step, we check if this is the case, and report again what the input is. 

```{r checkInput}
expectedNames = c("taxa1","taxa2","taxa3","taxa4",
                  "quadruple","triple1","triple2",
                  "triple3","triple4","status")
stopifnot(names(data) %in% expectedNames)
stopifnot(class(data$taxa1) == "integer")

x = table(data$status)
n = data$taxa4[dim(data)[1]]

if(verbose == T){
  message("Using ",as.numeric(x[1])," of ",dim(data)[1], 
          " quadruples as input for algorithm (",n,
          " unique taxa). \n This leaves ", as.numeric(x[2]),
          " quadruples unsolved.")}
```

## Set parameters

We create some parameters:

* index=0: running index for the upcoming loop
* round=0: new column in data set; should be set to round in which the quadruple can be resolved (e.g. round 0 for all input quadruples, round 1 for quadruples resolved in the first repeat loop)
* fixingTaxa=0: used fixing taxon to resolve the quadruple (e.g. fixing taxa 0 for all input quadruples, fixing taxa > 0 for all resolved quadruples)

```{r setParameters}
data2<-data.table::copy(data)
index=0
data2[,round := 0]
data2[,fixingTaxa := 0]
knitr::kable(data2[,c(5,10:12)], caption = "Data before repeat loop")

```

# Step 2: Repeat loop 

In the second step, we start a *repeat* loop. It contains the following sub-steps: 

1. Apply function *myAlgorithm* and increase index parameter by 1
2. Check for change and break the *repeat* loop if
    * there are no more unresolved quadruples (--> phylo. dec.) or
    * there are no new resolved quadruples (--> not phylo dec. or not resolvable via this algorithm)

```{r repeatLoop, eval=F}
repeat{
  data2=myAlgorithm(data = data2,
                    roundnumber = index,
                    verbose = verbose)
  index=index+1
  data2

  # Loop should stop if there are no new resolved quadruples or no unresolved quadruples
  check1 = (sum(data2$round == index) == 0)
  check2 = (sum(data2$status == "unresolved") == 0)
  if (check1 | check2){
    break
  }
}
```
    
The *myAlgorithm* function tests there are fixing taxa for unresolved quadruples given the input quadruples. That happens in the following four steps. 

## Step 2.1: Split data

First, we split the given data by their status: a quadruple is either unresolved and hence tested for fixing taxa or input/resolved and can be used to find the fixing taxa. 

```{r splitData}
data_solved = data2[status != "unresolved"]
data_unresolved = data2[status == "unresolved"]
knitr::kable(data_unresolved, caption = "Unresolved quadruples")
```

## Step 2.2: Foreach loop

A *foreach* loop is simply a for loop with some advantages regarding parallelization (not yet implemented). It tests wach unresolved quadruple for a fixing taxon. In this example, we only use $i=1$. 

```{r foreachLoop0}
# Example for i=1
i=1
data_unresolved[i,quadruple]
```

### Step 2.2.1: Get all triples

We create a vector containing all four triples that can be constructed using the four taxa of the unresolved quadruple (cross quadruple, CQ)

```{r foreachLoop1}
triples_CQ<-data_unresolved[i,c("triple1","triple2","triple3","triple4")]
triples_CQ = unique(unlist(triples_CQ))
triples_CQ

```


### Step 2.2.2: Check overlap with resolved triples

Next, we check if these CQ based triples occur in the resolved data. 

```{r foreachLoop2}
vgl1<-is.element(data_solved$triple1,triples_CQ)
vgl2<-is.element(data_solved$triple2,triples_CQ)
vgl3<-is.element(data_solved$triple3,triples_CQ)
vgl4<-is.element(data_solved$triple4,triples_CQ)

filt<-vgl1 | vgl2 | vgl3 | vgl4
data_pos<-data_solved[filt,]
knitr::kable(data_pos[,5:9], caption = "Resolved quadruples that cover at least one triple of the analyzed CQ")

```

In this example, there are 7 input/resolved quadruples, that share at least one triple with our unresolved one. This means, there are 7 taxa that can be tried as fixing taxa (CQ based triple + taxon $x$ = resolved or input quadruple).   

### Step 2.2.3: Search for fixing taxa 

Now we count the fourth taxa that is not in the triple. If one taxa $x$ appears four times, then all four quadruples of the CQ triples + $x$ are in the input data, and $x$ is a fixing taxon for the unresolved CQ. 

```{r foreachLoop3}
taxa_pos = unlist(data_pos[,c("taxa1","taxa2","taxa3","taxa4")])
taxa_unresolved = unique(unlist(data_unresolved[i,c("taxa1","taxa2","taxa3","taxa4")]))
taxa_pos2 = taxa_pos[!is.element(taxa_pos,taxa_unresolved)]
tab = data.table::data.table(taxa_ID = taxa_pos2)
tab2 = tab[,.N, by=taxa_ID]
knitr::kable(tab2, caption = "Possible fixing taxa and their count")
tab3 = tab2[N == max(N),]
if(dim(tab3)[1]>1){tab3 = tab3[1,]}

```

So taxa $5$ appears in three quadruples (1235, 1245, and 2345), and taxa $6$ four quadruples (1236, 1246, 2346, and 2346) - taxa $6$ is a fixing taxa for unresolved quadruple 1234. 

### Step 2.2.4: Return data

As result, we generate a data table with the unresolved quadruple, the best fixing taxa and the number of its counts. 

```{r foreachLoop4}
res = data.table::data.table(unres_quad = data_unresolved[i,quadruple],
                             best_fixTaxa = tab3$taxa_ID,
                             count = tab3$N)
knitr::kable(res, caption = "Possible fixing taxon with its highest count")

```


## Step 2.3: Check count

After the *foreach* loop, we have a data table containing all our unresolved quadruples:

```{r foreachLoop5}
myTab = foreach::foreach(i = 1:dim(data_unresolved)[1]) %do%{
  # i=1
  
  # Step 2.2.1: Get all triples
  triples_CQ<-data_unresolved[i,c("triple1","triple2","triple3","triple4")]
  triples_CQ = unique(unlist(triples_CQ))
  
  # Step 2.2.2: Check overlap with resolved triples
  vgl1<-is.element(data_solved$triple1,triples_CQ)
  vgl2<-is.element(data_solved$triple2,triples_CQ)
  vgl3<-is.element(data_solved$triple3,triples_CQ)
  vgl4<-is.element(data_solved$triple4,triples_CQ)
  filt<-vgl1 | vgl2 | vgl3 | vgl4
  data_pos<-data_solved[filt,]
  
  if(dim(data_pos)[1]!=0){
    # Step 2.2.3: Search for fixing taxa 
    taxa_pos = unlist(data_pos[,c("taxa1","taxa2","taxa3","taxa4")])
    taxa_unresolved = unique(unlist(data_unresolved[i,c("taxa1","taxa2","taxa3","taxa4")]))
    taxa_pos2 = taxa_pos[!is.element(taxa_pos,taxa_unresolved)]
    tab = data.table::data.table(taxa_ID = taxa_pos2)
    tab2 = tab[,.N, by=taxa_ID]
    tab3 = tab2[N == max(N),]
    if(dim(tab3)[1]!=0){tab3 = tab3[1,]}
    
    # Step 2.2.4: Return data
    res = data.table::data.table(unres_quad = data_unresolved[i,quadruple],
                                 best_fixTaxa = tab3$taxa_ID,
                                 count = tab3$N)
    
  }else{
    # Step 2.2.4: Return data
    res = data.table::data.table(unres_quad = data_unresolved[i,quadruple],
                                 best_fixTaxa = 0,
                                 count = 0)
  }
  
  res
}
myTab = data.table::rbindlist(myTab)
myTab

```

We check for how many unresolved quadruples there are best fixing taxa with $count\geq 4$. Those can be set to *resolved*, they get as round the current round and as fixing taxa the best fixing taxa. 

```{r CheckCount}
roundnumber = index
round_old = max(data2$round)
stopifnot(myTab$unres_quad == data_unresolved$quadruple)
filt = myTab$count>=4
data_unresolved[filt,status := "resolved"]
data_unresolved[filt,fixingTaxa := myTab[filt,best_fixTaxa]]
data_unresolved[filt,round := roundnumber + 1]
knitr::kable(data_unresolved[,c(5,10:12)], caption = "Unresolved quadruples after the foreach loop")
```


## Step 2.4: Return data

Finally, we return the data set to the *repeat* loop. 

```{r returnData1}
data3 = rbind(data_solved,data_unresolved)
table(data3$status)
tab4<-data3[,.N,by=status]
n_unresolved_new = tab4[status == "unresolved",N]
if (length(n_unresolved_new)==0){n_unresolved_new = 0}
n_unresolved_old = dim(data_unresolved)[1]
n_diff = n_unresolved_old - n_unresolved_new
round_new = max(data3$round)
if(round_new == round_old){round_new = round_new + 1}

if(verbose == T){message("In round #",round_new,", ",n_diff," quadruples could be resolved ...")}

```

After returning the new data set with updated status, we check for change and break the *repeat* loop if
    * there are no more unresolved quadruples (--> phylo. dec.) or
    * there are no new resolved quadruples (--> not phylo dec. or not resolvable via this algorithm)

```{r}
# copied from the chunk 7 and set to data3 as example
check1 = (sum(data3$round == index) == 0)
check2 = (sum(data3$status == "unresolved") == 0)
check1 | check2

```

Both checks are FALSE (in the last call of the algorithm quadruples could be solved and there are still unsolved ones), so the *repeat* loop goes into the next round. If one of them were TRUE, the loop stops. 

# Step 3: Return data and result

As soon as the *repeat* loop stops, we can evaluate our findings: can all cross-quadruples be resolved by fixing taxa (in multiple rounds)? If so, the data set is phylogenically decisive. If not, it is either not phylogenically decisive or not resolvable via fixing taxa. 

```{r}
# copied from the chunk 7 and set to data3 as example - just one round
if(verbose == T){
  if (sum(data3$status == "unresolved") ==0){
    print("PHYLOGENETICALLY DECISIVE")
  }else{
    print("NOT RESOLVABLE VIA THIS ALGORITHM, MAYBE A SECOND FIXING TAXON IS NEEDED")
  }
}
```

# Example using PhyloDecR

Now we use the previous data set and apply the functions from our PhyloDecR package. 

## Load data

```{r example1}
fn2 = system.file("extdata", 
                  "example_2_Decisive.txt", 
                  package = "PhyloDecR")

test2 = createInput(fn=fn2, sepSym = ",")

knitr::kable(test2$input_raw,caption = "Input from text file. Does not need to be numeric, does not need to be quadruples")

knitr::kable(test2$input_quadruples,caption = "Input quadruples. If in input was a tree with more than four taxa, all quadruples in that tree are added here")

knitr::kable(test2$input_ordered,caption = "Input quadruples, all numeric from 1 to n (different taxa in input).")

knitr::kable(test2$taxa, caption = "Transfomation matrix in case of character taxa")

knitr::kable(test2$data, caption = "Input data for algorithm")


```

The input files look like:

* input_raw: data as given in the .txt file.
* input_quadruples: interim result, data transformed into quadruples only
* input_ordered: data transformed to quadruples, and taxa ID forced to numeric and ordered hierarchically
* data: all possible quadruples given the taxon set with status information (quadruple as input available, quadruple not in input = unresolved). In addition, all four triples possible by each quadruple are listed
* taxa: data table used for transformation, taxaID denotes the original input taxaID (as in input_raw & input_quadruples), NR is the ordered number of this taxon (as in input_ordered & data)

## Test data

Now we test our data for fixing taxa and phylogenetic decisiveness. 

```{r example2}
test2_alg<-runAlgorithm(data = test2$data,verbose = T)
knitr::kable(test2_alg, caption = "Output data of algorithm")

```

# To do:

* add documentation for *FixingTaxonTraceability.R*


# Runtime 

* n = number of taxa
* N = number of possible quadruples with n taxa
* k = number of input quadruples
* N-k = unresolved quadruples

Worst case scenario: I can solve only one quadruple at each *repeat* loop --> O(N-k)

Checking overlap for each triple: four times all solved quadruples --> O(4k)

Search for taxa: all but the four taxa of the analyzed quadruple are possible --> O(n-4)

Taken together: $O((N-k) * (4k+n-4))$?
